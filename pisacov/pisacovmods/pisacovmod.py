# -*- coding: utf-8 -*-

import os
import subprocess
import shutil
import xml.etree.ElementTree as ET
from conkit import io as ckio
from conkit import plot as ckplot

from .init2 import pdbid

from .output import output_dir
from .output import output_tmpdir
from .output import printout
#from .output import sysfileout
#from .output import stdoutpath
from .output import interrupt

from .inputvalues import PISA_PATH
from .inputvalues import PDB_PATH
from .inputvalues import HHBLITS_VIA_DMP
from .inputvalues import HHSUITE_PATH
from .inputvalues import HHBLITS_DATABASE_DIR
from .inputvalues import HHBLITS_DATABASE_NAME
from .inputvalues import SEQUENCE_PATH
from .inputvalues import DMP_PATH

#from .sequence import biochain_ends
#from .sequence import renumberpdbs
from .sequence import biofile

#########################################################
##### PISACOV MAIN FUNCTIONS ############################

def runpisa(isitbio,outdir=output_tmpdir("pisa")):
    """
    Run PISA and generate interface PDB files for given PDB

    Parameters
    ----------
    isitbio : bool
        Specify whether using the ".bio" label in files or not.
    outdir : str, optional
        Directory where results of PISA will be printed out. The default is output_tmpdir("pisa").

    Returns
    -------
    n_int : int
        Number of candidate interfaces identified by PISA.

    """
    # new ID
    pfx = 'pisacov_'
    #locpdbid = os.path.splitext(os.path.basename(PDB_PATH))[0]
    pID = pfx+os.path.splitext(os.path.basename(PDB_PATH))[0]

    # Run PISA
    pisa_exec='"'+PISA_PATH+'"'
    #os.system(pisa_exec + ' '+ pID + ' -analyse ' + PDB_PATH + sysfileout())
    try:
        stdoutput=subprocess.check_output(pisa_exec + ' '+ pID + ' -analyse ' + PDB_PATH, stderr=subprocess.STDOUT,shell=True)
    except:
        printout(stdoutput)
        interrupt("ERROR: An error occurred during the execution of PISA (analysis).")

    printout(stdoutput)
    #with open(stdoutpath(), 'a') as out:
        #out.write(stdoutput)

    # Parse PISA xml file

    xmlfile=pdbid()+".interface.xml"
    xmlpath = os.path.join(outdir, xmlfile)
    os.system(pisa_exec + ' '+ pID + ' -xml interface > ' + xmlpath )

    # Obtain number of interfaces generated by PISA
    n_int = n_int_xml()

    printout(str(n_int)+' Interfaces identified',extraline=True)

    # Generate PDB files for each interface
    printout("Generating interface PDB files...")
    #pdbends=biochain_ends('pdb')
    for nif in range(1,n_int+1):
        #Write pdb files
        pdbfile=pdbid()+".interface."+str(nif)+".pdb"
        newpath = os.path.join(outdir, pdbfile)
        try:
            os.system(pisa_exec + ' '+ pID + ' -pdb interface '+ str(nif)+' > ' + newpath)
        except:
            interrupt("ERROR: An error occurred during the execution of PISA (interface pdb files production).")

    printout("  DONE",extraline=True)
    return n_int

def n_int_xml(xml_path=os.path.join(output_tmpdir("pisa"), pdbid()+".interface.xml")):
    """
    Read xml pisa file, parse it, and return number of interfaces

    Parameters
    ----------
    xml_path : str, optional
        Path to xml file. The default is os.path.join(output_tmpdir("pisa"), pdbid()+".interface.xml").

    Returns
    -------
    n : int
        Number of interfaces.

    """
    try:
        xmlparse = ET.parse(xml_path)
    except OSError:
        interrupt("ERROR: Unable to open XML file at " + xml_path)
    root = xmlparse.getroot()

    n=int(root.find('n_interfaces').text)
    return n

def runhhblits(isitbio, outdir=output_dir(), param=None, spath=SEQUENCE_PATH):
    """
    Run HHSUITE to produce a Multiple Sequence Alignment from a single fasta sequence.

    Parameters
    ----------
    isitbio : bool
        Specify whether using the ".bio" label in files or not.
    outdir : str, optional
        Directory where results of HHSUITE will be printed out. The default is output_dir().
    param : list (int,float), dim=2, optional
         HHBLITS SEQUENCE ALINGMENT PARAMETERS. The default is None, which implies the default parameters [2 , 0.001].
    spath : str, optional
        Sequence path. The default is SEQUENCE_PATH.

    Returns
    -------
    parsedmsa : msa
        ConKit parsed MSA.
    msajonespath : str
        MSA (jones format) file path.

    """

    # Obtain Multiple Sequence Alignment with HHblits
    msaa3mfile= pdbid()+biofile(isitbio)+".msa.a3m"
    msaa3mpath = os.path.join(outdir, msaa3mfile)

    hhsuite_exec='"'+HHSUITE_PATH+'"'
    if param is None or param == [ 2 , 0.001, 1000, 0, 90 ]:
        #os.system(hhsuite_exec + ' -i '+ spath + ' -d ' + HHBLITS_DATABASE_DIR + HHBLITS_DATABASE_NAME +' -oa3m ' + msaa3mpath + sysfileout())
        try:
            stdoutput=subprocess.check_output(hhsuite_exec + ' -i '+ spath + ' -d ' + HHBLITS_DATABASE_DIR + HHBLITS_DATABASE_NAME +' -oa3m ' + msaa3mpath, stderr=subprocess.STDOUT,shell=True)
        except:
            printout(stdoutput)
            interrupt("ERROR: An error occurred during the execution of HHSUITE.")
    else:
        #os.system(hhsuite_exec + ' -i '+ spath + ' -d ' + HHBLITS_DATABASE_DIR + HHBLITS_DATABASE_NAME + ' -n ' + str(param[0]) + ' -e ' + str(param[1]) + ' -oa3m ' + msaa3mpath + sysfileout())
        try:
            stdoutput=subprocess.check_output(hhsuite_exec + ' -i '+ spath + ' -d ' + HHBLITS_DATABASE_DIR + HHBLITS_DATABASE_NAME + ' -n ' + str(param[0]) + ' -e ' + str(param[1]) + ' -oa3m ' + msaa3mpath + ' -diff ' + str(param[2]) + ' -cov ' + str(param[3]) + ' -id ' + str(param[4]), stderr=subprocess.STDOUT, shell=True)
        except:
            printout(stdoutput)
            interrupt("ERROR: An error occurred during the execution of HHSUITE.")
    printout(stdoutput)
#   with open(stdoutpath(), 'a') as out:
#       out.write(stdoutput)

    # Convert A3M MSA file to Jones format (DMP standard input format)
    parsedmsa, msajonespath = msafilesgen(msaa3mpath)

    return parsedmsa, msajonespath

def rundmp(seq_path,msa_path,skiphhblits=False,skipdmp=False):
    """
    Run DeepMetaPSICOV to produce a contact list. Output automatically on same directory cotaining .fasta file.

    Parameters
    ----------
    seq_path : str
        Sequence (.fasta) path
    msa_path : str
        Multiple Sequence Alignment (.aln) path
    skiphhblits : bool, optional
        Skip DMP execution of hhblits. The default is False.
    skipdmp : bool, optional
        Skip DMP execution and perform only file operations. The default is False.
        
    Returns
    -------
    parsedmsa : msa
        ConKit parsed MSA. Only if HHBLITS_VIA_DMP==True
    msajonespath : str
        MSA (jones format) file path. Only if HHBLITS_VIA_DMP==True

    """
    if HHBLITS_VIA_DMP:
        msa_path = os.path.join(os.path.splitext(seq_path)[0]+".a3m")
        
    if HHBLITS_VIA_DMP and not skiphhblits:
        dmp_exec = '"'+DMP_PATH+'"'  + ' -i '+ seq_path
    else:
        dmp_exec = '"'+DMP_PATH+'"'  + ' -i '+ seq_path + ' -a ' + msa_path
    
    if not skipdmp:
        try:       
            stdoutput=subprocess.check_output(dmp_exec,stderr=subprocess.STDOUT,shell=True)
        except:
            interrupt("ERROR: An error occurred during the execution of DeepMetaPSICOV.")
        printout(stdoutput)
    else:
        printout('Skipping DeepMetaPSICOV execution.')

    if HHBLITS_VIA_DMP:        
        msaa3mfile = os.path.join(os.path.basename(os.path.splitext(seq_path)[0])+".a3m")
        msaa3mpath = os.path.join(output_dir(),msaa3mfile)
        shutil.copyfile(msa_path,msaa3mpath)
        
        parsedmsa, msajonespath = msafilesgen(msaa3mpath)
        return parsedmsa, msajonespath

def msafilesgen(inpath_a3m):
    """
    Convert a3m format alignment to "jones" format (.aln) and print msa coverage graph

    Parameters
    ----------
    inpath_a3m : str
        Multiple Sequence Alignment (.a3m) path

    Returns
    -------
    parsemsa : msa
        ConKit parsed MSA.
    outpath_aln : str
        MSA (jones format) file path.

    """
    outpath_aln = os.path.join(os.path.splitext(inpath_a3m)[0]+".aln")
    
    biotag = os.path.splitext(os.path.splitext(inpath_a3m)[0])[1]
    
    msacoveragefile = pdbid()+biotag+".msa.coverage.png" if biotag == ".bio" else pdbid()+".msa.coverage.png"
    msacoveragepath = os.path.join(output_dir(), msacoveragefile)

    parsemsa=ckio.read(inpath_a3m,'a3m')
    ckio.write(outpath_aln,'jones',parsemsa)

    ckplot.SequenceCoverageFigure(parsemsa, file_name=msacoveragepath)
    
    return parsemsa, outpath_aln